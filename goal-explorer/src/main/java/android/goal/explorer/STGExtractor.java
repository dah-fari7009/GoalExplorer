package android.goal.explorer;

import android.goal.explorer.analysis.value.AnalysisParameters;
import android.goal.explorer.analysis.value.PropagationIcfg;
import android.goal.explorer.analysis.value.managers.ArgumentValueManager;
import android.goal.explorer.analysis.value.managers.MethodReturnValueManager;
import android.goal.explorer.analysis.value.transformers.field.FieldTransformerManager;
import android.goal.explorer.builder.LifecycleCallbackFilter;
import android.goal.explorer.builder.ScreenBuilder;
import android.goal.explorer.builder.TransitionBuilder;
import android.goal.explorer.cmdline.GlobalConfig;
import android.goal.explorer.model.App;
import android.goal.explorer.model.component.Activity;
import android.goal.explorer.model.component.Fragment;
import android.goal.explorer.model.stg.STG;
import android.goal.explorer.topology.TopologyExtractor;
import org.pmw.tinylog.Logger;
import soot.PackManager;
import soot.Scene;
import soot.SootClass;
import soot.jimple.infoflow.android.SetupApplication;
import soot.jimple.infoflow.android.callbacks.filters.AlienHostComponentFilter;
import soot.jimple.infoflow.android.callbacks.filters.ApplicationCallbackFilter;
import soot.jimple.infoflow.android.callbacks.filters.UnreachableConstructorFilter;
import soot.jimple.infoflow.util.SystemClassHandler;
import st.cs.uni.saarland.de.entities.Application;
import st.cs.uni.saarland.de.entities.Dialog;
import st.cs.uni.saarland.de.entities.Menu;
import st.cs.uni.saarland.de.entities.XMLLayoutFile;
import st.cs.uni.saarland.de.helpClasses.Helper;
import st.cs.uni.saarland.de.reachabilityAnalysis.UiElement;
import st.cs.uni.saarland.de.testApps.AppController;
import st.cs.uni.saarland.de.testApps.Settings;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static st.cs.uni.saarland.de.testApps.TestApp.initializeSootForUiAnalysis;
import static st.cs.uni.saarland.de.testApps.TestApp.performUiAnalysis;
import static st.cs.uni.saarland.de.testApps.TestApp.runReachabilityAnalysis;

public class STGExtractor {
    // Logging tags
    private static final String RESOURCE_PARSER = "ResourceParser";
    private static final String FRAGMENT_ANALYZER = "FragmentAnalyzer";
    private static final String CALLBACK_ANALYZER = "CallbackAnalyzer";
    private static final String CLASS_ANALYZER = "JimpleAnalyzer";
    private static final String ICC_PARSER = "IccParser";
    private static final String GRAPH_BUILDER = "GraphBuilder";

    // Configuration
    private GlobalConfig config;

    // Model for the current apk being analyzed
    private App app;
    public App getApp() {
        return app;
    }

    // BACKSTAGE app model
    private Application backstageApp;
    public Application getBackstageApp() {
        return backstageApp;
    }

    private SetupApplication flowDroidApp;
    public SetupApplication getFlowDroidApp() {
        return flowDroidApp;
    }

    // Entrypoints
    private Set<SootClass> entrypoints;
    public Set<SootClass> getEntrypoints() {
        return entrypoints;
    }

    // Screen transition graph
    private STG stg;
    public STG getStg() {
        return stg;
    }

    /**
     * Default constructor
     * @param config The configuration file
     */
    public STGExtractor(GlobalConfig config, Settings settings) {
        // run backstage and merge the app object
        backstageApp = runBackstage(settings);

        // Setup analysis config
        this.config = config;

        // Setup the app using FlowDroid
        Logger.debug("Creating app model using FlowDroid");
        flowDroidApp = new SetupApplication(config.getFlowdroidConfig());

        // Initializes the app to proper state
        initialize(flowDroidApp);

        this.entrypoints = flowDroidApp.getEntrypointClasses();

        // initialize backstage
        Helper.loadNotAnalyzedLibs();
        Helper.loadBundlesAndParsable();
        Helper.deleteLogFileIfExist();
    }


    /**
     * Perform the whole analysis
     */
    public void constructSTG() {
        // initialize the STG with services and broadcast receivers
        stg = new STG(app);

        // topology - (1) construct callgraph (2) collect lifecycle and callback methods for each component
        Logger.debug("Starting Topology collection");
        collectTopology(config.getTimeout(), config.getNumThread());

        mergeResults(app, backstageApp);

        // register propagation analysis
        registerPropagationAnalysis();

        // build the initial and transition screens
        collectScreens();

        // collect transitions
        collectTransitions();
    }

    /**
     * Merge the results from backstage and our topology analyzer
     * @param app The app model generated by our approach
     * @param backstageApp The app model generated by Backstage model
     */
    private void mergeResults(App app, Application backstageApp) {

        int numDialogs = backstageApp.getDialogs().size();
        int numMenus = backstageApp.getMenus().size();
        int numUiElementsWithListeners = backstageApp.getUiElementsWithListeners().size();
        int numActivities = backstageApp.getActivities().size();
        int numXmlLayoutFiles = backstageApp.getXmlLayoutFiles().size();
        int numFragmentClassToLayout = backstageApp.getFragmentClassToLayout().size();

        String resultString = "Result of Analysis\n"
                .concat(String.format("\t numDialogs: %d\n", numDialogs))
                .concat(String.format("\t numMenus: %d\n", numMenus))
                .concat(String.format("\t numUiElementsWithListeners: %d\n", numUiElementsWithListeners))
                .concat(String.format("\t numActivities: %d\n", numActivities))
                .concat(String.format("\t numXmlLayoutFiles: %d\n", numXmlLayoutFiles))
                .concat(String.format("\t numFragmentClassToLayout: %d\n", numFragmentClassToLayout));

        Logger.debug(resultString);


        // dialogs and menus
        Map<Integer, Dialog> dialogMap = backstageApp.getDialogs();
        Map<Integer, Menu> menuMap = backstageApp.getMenus();

        for (UiElement uiElement : backstageApp.getUiElementsWithListeners()) {
            String declaringClass = uiElement.declaringSootClass;
            Activity curActivity = app.getActivityByName(declaringClass);
            if (curActivity != null) {
                curActivity.addUiElement(uiElement.globalId, uiElement);
            } else {
                Logger.warn("[WARN] cannot find activity {}", declaringClass);
            }
        }

        // add UI elements & layouts to activities
        for (Activity activity : app.getActivities()) {
            st.cs.uni.saarland.de.entities.Activity backActivity = backstageApp.getActivityByName(activity.getName());
            if (backActivity == null) {
                continue;
            }
            for (Integer layoutId : backActivity.getXmlLayouts()) {
                // check if the layout id maps to a layout file
                XMLLayoutFile layout = backstageApp.getXmlLayoutFile(layoutId);
                if (layout != null) {
                    activity.addLayout(layoutId, layout);
                }

                // add UI element if the resource id maps to an UI element
                UiElement uiElement = backstageApp.getUiElementWithListenerById(layoutId);
                if (uiElement != null) {
                    activity.addUiElement(layoutId, uiElement);
                }

                // check if the XML file is a menu
                Dialog dialog = dialogMap.get(layoutId);
                Menu menu = menuMap.get(layoutId);
                if (dialog != null) {
                    activity.addDialog(dialog);
                }
                if (menu != null) {
                    activity.setMenu(menu);
                }
            }
            Logger.info("Updated Activity:" + activity.toString());
        }

        // add UI elements to fragments
        for (Map.Entry<String, Set<Integer>> fragmentEntry : backstageApp.getFragmentClassToLayout().entrySet()) {
            app.addFragment(new Fragment(Scene.v().getSootClassUnsafe(fragmentEntry.getKey()), fragmentEntry.getValue()));
        }
    }

    /**
     * Use BACKSTAGE to process the app
     */
    private Application runBackstage(Settings settings) {
        long beforeRun = System.nanoTime();
        initializeSootForUiAnalysis(settings.apkPath, settings.androidJar, settings.saveJimple, false);
        AppController appResults = performUiAnalysis(settings);
        if(appResults == null){
            return null;
        }
        Helper.saveToStatisticalFile("UI Analysis has run for " + (System.nanoTime() - beforeRun) / 1E9 + " seconds");
        PackManager.v().writeOutput();

        List<UiElement> uiElementObjectsForReachabilityAnalysis =
                appResults.getUIElementObjectsForReachabilityAnalysis(true);
        List<UiElement> distinctUiElements = uiElementObjectsForReachabilityAnalysis
                .stream().distinct().collect(Collectors.toList());
        runReachabilityAnalysis(distinctUiElements, appResults.getActivityNames(), settings);
        return AppController.getInstance().getApp();
    }

    /**
     * Collects the topology (lifecycle and callback methods for each component)
     * @param timeout The max timeout when analyzing each component (default: 5 minutes)
     * @param numThread The number of threads used in parallel analysis
     */
    public void collectTopology(Integer timeout, Integer numThread) {
        TopologyExtractor topologyExtractor = new TopologyExtractor(app, timeout, numThread);
        topologyExtractor.extractTopopology();
    }

    /**
     * Collects the screens
     */
    private void collectScreens() {
        ScreenBuilder screenBuilder = new ScreenBuilder(app, stg, backstageApp, config);
        screenBuilder.addCallbackFilter(new AlienHostComponentFilter(entrypoints));
        screenBuilder.addCallbackFilter(new ApplicationCallbackFilter(entrypoints));
        screenBuilder.addCallbackFilter(new UnreachableConstructorFilter());
        if (app.getApplication() == null)
            screenBuilder.addCallbackFilter(new LifecycleCallbackFilter((String) null));
        else
            screenBuilder.addCallbackFilter(new LifecycleCallbackFilter(app.getApplication().getMainClass()));

        screenBuilder.constructScreens();
    }

    /**
     * Collects all transitions in the app
     */
    public void collectTransitions() {
        TransitionBuilder transitionBuilder = new TransitionBuilder(stg);
        transitionBuilder.collectTransitions();
        stg = transitionBuilder.stg;
    }


    /**
     * initialize the app model
     */
    public void initialize(SetupApplication setupApplication) {
        // Construct the callgraph
        setupApplication.constructCallgraph();

        // initialize the model
        app = new App();
        app.initializeAppModel(setupApplication);
    }

    /**
     * Registers propagation analysis
     */
    private void registerPropagationAnalysis() {
        AnalysisParameters.v().setIcfg(new PropagationIcfg());

        // Register field analysis
        FieldTransformerManager.v().registerDefaultFieldTransformerFactories();

        // Register value analysis
        ArgumentValueManager.v().registerDefaultArgumentValueAnalyses();

        // Register method return value analysis
        MethodReturnValueManager.v().registerDefaultMethodReturnValueAnalyses();

        // Add application classes (other classes will be ignored during the propagation)
        Set<String> analysisClasses = new HashSet<>();
        Scene.v().getApplicationClasses().snapshotIterator().forEachRemaining(x -> {
            String className = x.getName();
            if (!SystemClassHandler.isClassInSystemPackage(className)) {
                analysisClasses.add(className);
            }
        });
        AnalysisParameters.v().addAnalysisClasses(analysisClasses);
    }
}
