aspect Transformations {
  // generic traversal of the tree
  public void ASTNode.transformation() {
    for(int i = 0; i < getNumChild(); i++) {
        getChild(i).transformation();
    }
  }
  
  public void CompilationUnit.transformation() {
    if(fromSource()) {
      for(int i = 0; i < getNumTypeDecl(); i++) {
        getTypeDecl(i).transformation();
      }
    }
  }
  
  // remote collection
  public void TypeDecl.transformation() {
    super.transformation();
    if(isNestedType())
      enclosingType().addNestedType(this);
  }

  // remote collection
  public void TypeAccess.transformation() {
    super.transformation();
    if(type().isNestedType())
      hostType().addUsedNestedType(type());
  }
  
  // remote collection / demand driven creation of accessor
  public void MethodAccess.transformation() {
    MethodDecl m = decl();
    
    if(m.isPrivate() && !hostType().hasMethod(name())) {
      /* Access to private methods in enclosing types:
      The original MethodAccess is replaced with an access to an accessor method
      built by createAccessor(). This method is built lazily and differs from
      normal MethodDeclarations in the following ways:
      1) The method in the class file should always be static and the signature
         is thus changed to include a possible this reference as the first argument. 
      2) The method is always invoked using INVOKESTATIC
      3) The flags must indicate that the method is static and package private
      */
      replace(this).with(decl().createAccessor(methodQualifierType()).createBoundAccess(getArgList()));
      return;
    }
    else if(!m.isStatic() && isQualified() && prevExpr().isSuperAccess() && !hostType().instanceOf(prevExpr().type())) {
      decl().createSuperAccessor(superAccessorTarget());
    }
    super.transformation();
  }

  // remote collection / demand driven creation of accessor
  public void VarAccess.transformation() {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      if(requiresAccessor()) {
        TypeDecl typeDecl = fieldQualifierType();
        if(isSource())
          f.createAccessor(typeDecl);
        if(isDest())
          f.createAccessorWrite(typeDecl);
      }
    }
    super.transformation();
  }


  public void ConstructorDecl.transformation() {
    // this$val as fields and constructor parameters
    addEnclosingVariables();
    super.transformation();
  }

  // remote collection / demand driven creation of accessor
  public void ConstructorAccess.transformation() {
    // this$val
    addEnclosingVariables();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().createAccessor();
    }
    super.transformation();
  }

  // remote collection / demand driven creation of accessor
  public void SuperConstructorAccess.transformation() {
    // this$val
    addEnclosingVariables();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().createAccessor();
    }
    super.transformation();
  }
  
  // remote collection / demand driven creation of accessor
  public void ClassInstanceExpr.transformation() {
    // this$val
    addEnclosingVariables();
    // touch accessorIndex to force creation of private constructorAccessor
    if(decl().isPrivate() && type() != hostType()) {
      decl().createAccessor();
    }
    super.transformation();
  }

  // remote collection / demand driven creation of accessor
  public void ClassAccess.transformation() {
    super.transformation();
    // touch static class method before any accessors to make it first in method
    if(isQualified() && qualifier().type().isReferenceType()) {
      hostType().topLevelType().createStaticClassMethod();
      FieldDeclaration f = hostType().topLevelType().createStaticClassField(prevExpr().type().referenceClassFieldName());
    }
    
  }

  public void AssertStmt.transformation() {
    super.transformation();
    // add field to hold cached result as a side-effect
    FieldDeclaration f = hostType().topLevelType().createStaticClassField(hostType().topLevelType().referenceClassFieldName());
    FieldDeclaration assertionsDisabled = hostType().createAssertionsDisabled();
    Expr condition = getfirst();
    List args = new List();
    if(hasExpr()) {
      if(getExpr().type().isString())
        args.add(new CastExpr(new TypeAccess("java.lang", "Object"), getExpr()));
      else
        args.add(getExpr());
    }
    Stmt stmt = 
      new IfStmt(
        new LogNotExpr(
          new ParExpr(
            new OrLogicalExpr(
              new BoundFieldAccess(assertionsDisabled),
              condition
            )
          )
        ),
        new ThrowStmt(
          new ClassInstanceExpr(
            lookupType("java.lang", "AssertionError").createQualifiedAccess(),
            args,
            new Opt()
          )
        ),
        new Opt()
      );
     
    replace(this).with(stmt);
    stmt.transformation();
  }
  
  // imperative transformation of the AST
  // syntax ASTNode.replace(sourcenode).with(destnode)
  // this syntax is used to allow for building the destnode using the sourcenode
  protected static ASTNode ASTNode.replace(ASTNode node) {
    replacePos = node.getParent().getIndexOfChild(node);
    return node.getParent();
  }
  protected ASTNode ASTNode.with(ASTNode node) {
   ((ASTNode)this).setChild(node, replacePos);
   return node;
  }
  private static int ASTNode.replacePos = 0;
}
